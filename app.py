from flask import Flask, request, jsonify
from flask_cors import CORS
import google.generativeai as genai
import psycopg2
import json
from psycopg2.extras import RealDictCursor
from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity
from werkzeug.security import check_password_hash
from datetime import timedelta
import secrets
from datetime import datetime, timedelta # Make sure both are imported
import joblib 
import os     

# --- CONFIGURATION ---
NEON_DB_URI = "postgresql://neondb_owner:npg_AvhtTuP9MyJ1@ep-summer-flower-a84wueh2-pooler.eastus2.azure.neon.tech/neondb?sslmode=require&channel_binding=require" # PASTE YOUR NEON URI HERE
GOOGLE_API_KEY = "AIzaSyD1qNUDdxW7deQ-A48l3Qr3EtxWFjX5yO8" # PASTE YOUR GOOGLE API KEY HERE
JWT_SECRET_KEY = "super-secret-fixed-key-change-this-in-production"  # Secret for Tokens

app = Flask(__name__)
CORS(app)

# --- LOAD LOCAL BRAIN ---
try:
    local_model = joblib.load("local_brain.pkl")
    print("üß† Local Brain Loaded Successfully!")
except:
    print("‚ö†Ô∏è Local Brain NOT found. Running in Cloud-Only mode.")
    local_model = None

# --- SETUP ---
try:
    genai.configure(api_key=GOOGLE_API_KEY)
    model = genai.GenerativeModel('gemini-2.5-flash')
    print("Gemini LLM configured.")
except Exception as e:
    print(f"Error configuring Gemini: {e}")
    model = None

app = Flask(__name__)
CORS(app)

SERVER_START_TIME = datetime.now()
# JWT Setup
app.config["JWT_SECRET_KEY"] = JWT_SECRET_KEY
app.config["JWT_ACCESS_TOKEN_EXPIRES"] = timedelta(hours=24)
jwt = JWTManager(app)

# --- DATABASE HELPERS ---
def get_db_conn():
    """Establishes a connection to the Neon PostgreSQL database."""
    try:
        conn = psycopg2.connect(NEON_DB_URI, cursor_factory=RealDictCursor)
        return conn
    except Exception as e:
        print(f"Database Connection Error: {e}")
        return None

def execute_query(sql):
    """Helper to execute SQL generated by LLM"""
    conn = get_db_conn()
    if not conn: return "DB_ERROR: Connection failed"
    try:
        cur = conn.cursor()
        cur.execute(sql)
        results = cur.fetchall()
        conn.close()
        return [dict(row) for row in results]
    except Exception as e:
        conn.close()
        return f"DB_ERROR: {str(e)}"

def get_custom_intents():
    """Fetches custom training data (Test Case 3) to feed the LLM"""
    conn = get_db_conn()
    if not conn: return ""
    try:
        cur = conn.cursor()
        cur.execute("SELECT intent_name, example_text FROM training_data")
        rows = cur.fetchall()
        if not rows: return ""
        
        training_text = "\nCUSTOM TRAINING RULES (Prioritize these):\n"
        for row in rows:
            training_text += f"- If user says '{row['example_text']}' -> Return: INTENT:{row['intent_name']}\n"
        return training_text
    except: return ""
    finally: conn.close()

# ==========================================
# --- AUTHENTICATION ROUTES ---
# ==========================================

# 1. Admin Login (Test Cases 1 & 2)
@app.route("/auth/login", methods=["POST"])
def login():
    username = request.json.get("username", None)
    password = request.json.get("password", None)
    
    conn = get_db_conn()
    if not conn: return jsonify({"msg": "DB Connection Error"}), 500
    
    try:
        cur = conn.cursor()
        cur.execute("SELECT * FROM admins WHERE username = %s", (username,))
        user = cur.fetchone()
        
        if not user or not check_password_hash(user['password_hash'], password):
            return jsonify({"msg": "Invalid credentials"}), 401
        
        access_token = create_access_token(identity=username, additional_claims={"is_admin": True})
        return jsonify(access_token=access_token)
    finally:
        conn.close()

# 2. Customer Login (For User Panel)
@app.route("/auth/customer/login", methods=["POST"])
def customer_login():
    username = request.json.get("username", None)
    password = request.json.get("password", None)
    
    conn = get_db_conn()
    if not conn: return jsonify({"msg": "DB Connection Error"}), 500
    
    try:
        cur = conn.cursor()
        cur.execute("SELECT * FROM customers WHERE username = %s", (username,))
        user = cur.fetchone()
        
        if not user or not check_password_hash(user['password_hash'], password):
            return jsonify({"msg": "Invalid credentials"}), 401
        
        # Create Token with User ID
        access_token = create_access_token(identity=username, additional_claims={"is_customer": True})
        return jsonify({
            "access_token": access_token, 
            "user_id": user['id'],
            "name": user['full_name'],
            "account_number": user['account_number']
        })
    finally:
        conn.close()

# ==========================================
# --- CHAT ROUTE (Fixed Suggestions) ---
# ==========================================

@app.route("/chat", methods=["POST"])
def chat():
    user_text = request.json.get("message", "")
    session_id = request.json.get("session_id", "guest")
    user_id = request.json.get("user_id", None) 
    
    # 1. SETUP CONTEXT
    custom_training = get_custom_intents()
    customer_context = ""
    u_data = None 
    
    if user_id:
        conn = get_db_conn()
        try:
            cur = conn.cursor()
            cur.execute("SELECT * FROM customers WHERE id = %s", (user_id,))
            u_data = cur.fetchone()
            if u_data:
                customer_context = f"""
                [VERIFIED CUSTOMER DETAILS]
                Name: {u_data['full_name']}
                Account: {u_data['account_number']}
                Balance: ${u_data['balance']:,.2f}
                Loan: {u_data['loan_type'] if u_data['has_loan'] else 'None'}
                """
            conn.close()
        except: pass

    # 2. LOCAL BRAIN PRE-FETCH
    local_hint = "None"
    pre_fetched_data = None
    
    if local_model:
        try:
            probabilities = local_model.predict_proba([user_text]).max()
            prediction = local_model.predict([user_text])[0]
            if probabilities > 0.60:
                local_hint = prediction
                conn = get_db_conn()
                cur = conn.cursor()
                if prediction == "branches":
                    cur.execute("SELECT * FROM branches")
                    pre_fetched_data = [dict(row) for row in cur.fetchall()]
                elif prediction == "staff":
                    cur.execute("SELECT name, role FROM employees LIMIT 5")
                    pre_fetched_data = [dict(row) for row in cur.fetchall()]
                elif prediction == "balance":
                    pre_fetched_data = u_data if u_data else "LOGIN_NEEDED"
                elif prediction in ["hours", "contact", "loans", "credit_card", "greeting"]:
                    pre_fetched_data = "STATIC"
                conn.close()
        except: pass

    # 3. ATTEMPT GEMINI
    final_response = ""
    intent_log = "gemini"
    
    try:
        # Credit Saver
        if local_hint in ["greeting", "hours", "contact"] and pre_fetched_data == "STATIC":
            raise Exception("Skip Gemini (Credit Saver Mode)") 
            
        # PROMPT UPDATED: Strict separation of Main Answer vs. Suggestions
        prompt = f"""
        Act as 'Vaulty'. User: "{user_text}"
        Context: Local Hint: {local_hint}, Data: {json.dumps(pre_fetched_data, default=str)}, User: {customer_context}.
        
        INSTRUCTIONS:
        1. MAIN RESPONSE (Use HTML): 
           - Answer nicely. Use <b>bold</b> for key info.
           - If listing Branches: Add <br><a href='https://www.google.com/maps/search/?api=1&query=LOCATION_NAME' target='_blank' style='color:#facc15'>üìç View Map</a>
           - If checking Balance: Add <br><a href='https://www.google.com/search?q=nova+balance' target='_blank' style='color:#facc15'>üîó Transaction History</a>
           - If Loans/Cards: Add <br><a href='#' style='color:#facc15'>üëâ Apply Now</a>

        2. SUGGESTIONS (PLAIN TEXT ONLY):
           - End response with "|||" followed by 3 suggestions.
           - NO HTML or LINKS in suggestions. Keep them short (2-3 words).
           - Example: ||| Check Balance | Locations | Contact Support
        """
        final_response = model.generate_content(prompt).text

    except Exception as e:
        # Fallback Logic
        if "Quota" in str(e): print(f"‚ö†Ô∏è Gemini Quota Exceeded.")
        intent_log = "manual_fallback"
        
        if local_hint == "branches" and pre_fetched_data:
            final_response = "Here are our branches:<br>"
            for b in pre_fetched_data:
                final_response += f"‚Ä¢ <b>{b['branch_name']}</b> <a href='https://www.google.com/maps/search/?api=1&query=LOCATION_NAME' style='color:#facc15'>üìç Map</a><br>"
            final_response += "||| Check Balance | Contact | Retry"
        elif local_hint == "balance":
            if pre_fetched_data and pre_fetched_data != "LOGIN_NEEDED":
                final_response = f"Balance: <b>${pre_fetched_data['balance']:,.2f}</b><br><a href='#' style='color:#facc15'>üîó History</a> ||| Transfer | Home"
            else:
                final_response = "Please login. ||| Login"
        elif local_hint == "greeting":
            final_response = "Hello! I am Vaulty. ||| Login | Locations | Contact"
        elif local_hint == "hours":
            final_response = "We are open Mon-Fri, 9am-5pm. ||| Locations | Contact"
        elif local_hint == "contact":
            final_response = "Call 1-800-NOVA. ||| Locations | Home"
        else:
            final_response = "I am busy right now. ||| Retry"

    # 4. PARSE & RESPOND
    if "|||" in final_response:
        parts = final_response.split("|||")
        text_part = parts[0].strip()
        raw_suggestions = parts[1].strip()
        # Clean suggestions to ensure no HTML sneaks in
        if "|" in raw_suggestions:
            suggestions = [s.strip().replace("</a>","").replace("<b>","") for s in raw_suggestions.split("|") if s.strip()]
        else:
            suggestions = [s.strip().replace("</a>","").replace("<b>","") for s in raw_suggestions.split("\n") if s.strip()]
    else:
        text_part = final_response
        suggestions = []

    # 5. LOGGING WITH REAL NAMES
    if get_db_conn():
        try:
            conn = get_db_conn()
            cur = conn.cursor()
            
            # Determine who is talking
            sender_name = "Guest"
            if u_data:
                sender_name = u_data['full_name'] # Uses real name like "Tony Stark"
            
            # Save User Message
            cur.execute("INSERT INTO history (session_id, sender, message, intent) VALUES (%s, %s, %s, %s)", 
                        (session_id, sender_name, user_text, 'query'))
            
            # Save Bot Message
            cur.execute("INSERT INTO history (session_id, sender, message, intent) VALUES (%s, %s, %s, %s)", 
                        (session_id, 'Vaulty (Bot)', text_part, intent_log))
            
            conn.commit()
            conn.close()
        except Exception as e:
            print(f"Logging Error: {e}")

# ==========================================
# --- ADMIN PANEL ROUTES ---
# ==========================================

# Test Case 3: Add Intent
@app.route("/admin/intents", methods=["POST"])
@jwt_required()
def add_intent():
    data = request.json
    intent_name = data.get("intent_name")
    examples = data.get("examples")
    
    conn = get_db_conn()
    if not conn: return jsonify({"error": "DB Error"}), 500
    try:
        cur = conn.cursor()
        for ex in examples:
            cur.execute("INSERT INTO training_data (intent_name, example_text) VALUES (%s, %s)", (intent_name, ex))
        conn.commit()
        return jsonify({"status": "success"})
    finally: conn.close()

# Test Case 4: Filter Logs
@app.route("/admin/logs", methods=["GET"])
@jwt_required()
def get_logs_filtered():
    user_id = request.args.get("user_id")
    hours = request.args.get("hours")
    
    conn = get_db_conn()
    if not conn: return jsonify({"error": "DB Error"}), 500
    try:
        cur = conn.cursor()
        query = "SELECT sender, message, intent, timestamp, session_id FROM history WHERE 1=1"
        params = []
        
        if user_id:
            query += " AND session_id = %s"
            params.append(user_id)
        if hours:
            query += " AND timestamp >= NOW() - INTERVAL '%s hours'"
            params.append(hours)
            
        query += " ORDER BY id DESC LIMIT 50"
        cur.execute(query, tuple(params))
        rows = cur.fetchall()
        return jsonify([dict(row) for row in rows])
    finally: conn.close()

# Basic Stats & Branch Management
@app.route("/admin/stats", methods=["GET"])
def get_stats():
    conn = get_db_conn()
    if not conn: return jsonify({"error": "DB Failed"}), 500
    try:
        cur = conn.cursor()
        
        # 1. Total Interactions (Since Server Restart)
        # We filter by the timestamp when this Python script started running
        cur.execute("SELECT COUNT(*) as count FROM history WHERE timestamp >= %s", (SERVER_START_TIME,))
        total_msgs = cur.fetchone()['count']
        
        # 2. Active Users (Online in the last 15 Minutes)
        # We count unique session_IDs that have been active recently
        cur.execute("""
            SELECT COUNT(DISTINCT session_id) as count 
            FROM history 
            WHERE timestamp >= NOW() - INTERVAL '15 minutes'
        """)
        active_users = cur.fetchone()['count']
        
        return jsonify({
            "total_messages": total_msgs, 
            "total_users": active_users
        })
    finally: conn.close()

@app.route("/admin/branches", methods=["GET", "POST", "DELETE"])
def manage_branches():
    conn = get_db_conn()
    if not conn: return jsonify({"error": "DB Failed"}), 500
    try:
        cur = conn.cursor()
        if request.method == "GET":
            cur.execute("SELECT * FROM branches ORDER BY id ASC")
            return jsonify([dict(row) for row in cur.fetchall()])
        elif request.method == "POST":
            data = request.json
            if data.get("branch_id"):
                cur.execute("UPDATE branches SET branch_name=%s, city=%s, ifsc_code=%s, contact_number=%s WHERE id=%s", 
                            (data['branch_name'], data['city'], data['ifsc_code'], data['phone_number'], data['branch_id']))
            else:
                cur.execute("INSERT INTO branches (branch_name, city, ifsc_code, contact_number) VALUES (%s, %s, %s, %s)", 
                            (data['branch_name'], data['city'], data['ifsc_code'], data['phone_number']))
            conn.commit()
            return jsonify({"status": "success"})
        elif request.method == "DELETE":
            cur.execute("DELETE FROM branches WHERE id=%s", (request.args.get('id'),))
            conn.commit()
            return jsonify({"status": "deleted"})
    except Exception as e: return jsonify({"error": str(e)}), 500
    finally: conn.close()

# --- PASTE THIS INTO app.py (Before the "if __name__..." line) ---



# 2. MANAGE CUSTOMERS (Users)
@app.route("/admin/customers", methods=["GET", "POST", "DELETE"])
@jwt_required()
def manage_customers():
    conn = get_db_conn()
    if not conn: return jsonify({"error": "DB Failed"}), 500
    try:
        cur = conn.cursor()
        
        # GET: List all customers
        if request.method == "GET":
            cur.execute("SELECT id, username, full_name, account_number, balance FROM customers ORDER BY id ASC")
            return jsonify([dict(row) for row in cur.fetchall()])
            
        # POST: Add new customer (with Password Hashing)
        elif request.method == "POST":
            from werkzeug.security import generate_password_hash # Ensure this is imported
            data = request.json
            hashed_pw = generate_password_hash(data['password'])
            
            cur.execute("""
                INSERT INTO customers (username, password_hash, full_name, account_number, balance, account_type, has_loan, loan_outstanding) 
                VALUES (%s, %s, %s, %s, %s, 'Savings', FALSE, 0)
            """, (data['username'], hashed_pw, data['full_name'], data['account_number'], data['balance']))
            
            conn.commit()
            return jsonify({"status": "success"})
            
        # DELETE: Remove customer
        elif request.method == "DELETE":
            user_id = request.args.get('id')
            cur.execute("DELETE FROM customers WHERE id=%s", (user_id,))
            conn.commit()
            return jsonify({"status": "deleted"})
            
    except Exception as e: return jsonify({"error": str(e)}), 500
    finally: conn.close()

    # --- ADMIN: FETCH ALL USERS ---
@app.route("/admin/users", methods=["GET"])
def get_all_users():
    conn = get_db_conn()
    cur = conn.cursor()
    # Fetch all details needed for the Admin Panel
    cur.execute("SELECT id, full_name, username, account_number, balance FROM customers ORDER BY id ASC")
    users = [dict(row) for row in cur.fetchall()]
    conn.close()
    return jsonify(users)

# --- ADMIN: FETCH FULL LOGS ---
@app.route("/admin/logs", methods=["GET"])
def get_all_logs():
    conn = get_db_conn()
    cur = conn.cursor()
    # Fetch last 50 logs, newest first
    cur.execute("SELECT * FROM history ORDER BY timestamp DESC LIMIT 50")
    logs = [dict(row) for row in cur.fetchall()]
    conn.close()
    return jsonify(logs)
# ==========================================
# --- ADMIN: STAFF MANAGEMENT (Missing Part) ---
# ==========================================

@app.route("/admin/employees", methods=["GET", "POST", "DELETE"])
def manage_employees():
    conn = get_db_conn()
    cur = conn.cursor()

    # 1. VIEW ALL STAFF
    if request.method == "GET":
        cur.execute("SELECT * FROM employees ORDER BY id ASC")
        staff = [dict(row) for row in cur.fetchall()]
        conn.close()
        return jsonify(staff)

    # 2. ADD NEW STAFF
    if request.method == "POST":
        data = request.json
        cur.execute(
            "INSERT INTO employees (name, role, branch_name) VALUES (%s, %s, %s)",
            (data['name'], data['role'], data['branch_name'])
        )
        conn.commit()
        conn.close()
        return jsonify({"status": "Staff Added"})

    # 3. DELETE STAFF
    if request.method == "DELETE":
        staff_id = request.args.get("id")
        cur.execute("DELETE FROM employees WHERE id = %s", (staff_id,))
        conn.commit()
        conn.close()
        return jsonify({"status": "Staff Deleted"})

if __name__ == "__main__":
    app.run(debug=True, port=5000, host='0.0.0.0', use_reloader=False)